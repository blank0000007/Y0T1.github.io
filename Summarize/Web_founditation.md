###1 .URL（统一资源定位标识符）

```
https://www.example.com:80/path/to/myfile.html?key1=value1&key2=value2#anchor
```

首先介绍一下格式：协议 ==//== 主机 ==：==端口==/==路径 ==.html==   ==?==查询参数 ==#== 锚点

URI （统一资源标识符）一种概念—实现方式：URL（统一资源定位符）、URN（统一资源命名符）

> URN需要解析器对该目标文件的独一无二的、不变的字符串进行解密来推出当前所在位置

+ ==协议==：就是网络协议，在计算机网络中有具有规定信息交流的作用；包括http和https（超文本传输协议；网页），后者是前者的加密版本，具有更高的安全性（但目前http用的还是多）这样的协议还有FTP（文件传输协议；下载文件）、SMTP（电子邮件传输协议；发送接收电子邮件）

+ ==主机==：就是我们所需要的网页文件等在哪台服务器上，上述例子中的主机段写（包括平常写的www.  xxxxxx.com）是该网站所在的服务器的域名，在经过DNS服务器之后，会转换为IP地址（比如192.168.1.1等）；简单说就是该网站所存在的服务器的地址 （PS：如果记得IP地址的话，也可以用IP替换域名输入）

  >这里再额外介绍一下域名等级，例如baidu.com（一级域名），这里的.com只是域名后缀（顶级域名），而baidu才是域名主体，这里注意，前面我们并没有加入www. 如果加入了，那么www.baidu.com这就是个二级域名，依据前面共有几部分可向下分为一级、二级、三级域名等；需要注意的是，如果需要使用二级域名，首先必须注册对应的一级域名，单独只有二（三）级域名都是不可行的。下面是一些常见的顶级域名：

  | 顶级域名           | 用途                                               |
  | ------------------ | -------------------------------------------------- |
  | .com / .net  /.org | 目前来说使用没有限制（商业/网络服务商/非营利组织） |
  | .gov               | 政府机构                                           |
  | .edu               | 教育机构                                           |
  | .mil               | 军事机构                                           |

+ ==端口==：首先说明端口是干什么的：确定你所需要的服务，然后从这个门（端口）进去。平时在浏览网站时很少会见到这个东西，因为端口大多都是默认的（有对应关系）；端口还分为物理意义上的端口和逻辑意义上的端口，我们这里介绍的是逻辑意义上的端口（一般都是TCP/UDP协议中的端口），物理端口指的就是集线器，HUB，路由等；

  > 逻辑意义上的接口范围是0~65535（TCP/UDP都有65535个端口），其中公认端口（每个端口有明确的服务）0—1023，动态端口（不固定服务）1024—65535

  > TCP协议接口：发送信息以后，可以确认信息是否到达，也就是有应答的方式。
  >
  > UDP协议接口：发送以后就不管了，不去确认信息是否到达。

  | 端口号 | 服务                  |
  | ------ | --------------------- |
  | 20、21 | FTP（20连接、21传输） |
  | 25     | SMTP                  |
  | 53     | DNS                   |
  | 22     | SSH（安全外壳）       |
  | 443    | HTTPS                 |
  | 80     | HTTP                  |

+ ==路径==：简单来说就是我们计算机上的文件的位置，网页文件（.html）在服务器上也有相应的存储路径

  下面再来介绍一下相对路径和绝对路径

  >绝对路径：这个最简单理解，就是 E:\学习资料\Asia 这样的，后面可以跟上具体的 文件名字.文件格式 animal_video01.mp4
  >
  >相对路径：就是以当前的文件位置为基准，比如选取上面的Asia中的一个文件时可以直接输入animal_video02.mp4；如果我想要换成Europe（在学习资料目录下，与Asia同等级）就输入../Europe/animal_video01.mp4；如果是想要在当前目录继续向下就是2022/AKT01.mp4。总结一下就是，向上一级../ ，向下一级 /文件名

+ ==查询参数==：举个例子吧，在网上找百度网盘的资源时，会让你输入提取码，从URL上面来看 就是？后面会跟着一个password=xxxxxx，当你输入密码的时候，后面的xxxxxx就会变成你所输入的密码，也就是所说的参数；当然参数也不止这点功能，根据参数的不同，调用出来的界面也不一定相同（就像百度网盘提取码输入错误和正确，肯定是两个不同的界面）

+ ==锚点==：显示当前网页内部的定位符号，类似于一键返回顶端这个功能。

###2 .IP

IP地址目前分为IPv4和IPv6地址，常用的就是IPv4（例如192.168.1.1），位于OSI模型的网络层；一共分为A、B、C、D、E五类，IPv4地址共有4个字段，也就是说32bit，每8bit用十进制表示就形成了上面的例子；IP地址由两部分构成==网络地址和主机地址==，网络地址用于著名在哪个网络中，主机地址用于表明在这个网络中的位置；这里是各个等级对应的范围（其中全0，全1的IP地址保留不用）下面从二进制来看一下ABC三类地址的构造

| 等级                | 构造                     | 可用网络x主机数 |
| ------------------- | ------------------------ | --------------- |
| A类地址（大型网络） | 0+7位网络号+24位主机号   | 126*1G          |
| B类地址（中型网络） | 10+14位网络号+16位主机号 | 16382*60K       |
| C类地址（小型网络） | 110+21位网络号+8位主机号 | 2090K*254       |

<img src="F:\Picture\Saved Pictures\ip.png" style="zoom:80%;" />

**CIDR**：消除了上述IPV4的A、B、C类网络的概念，因为实在是不公平，对于低类网络来说，基数大，但是能有主机号少，而等级高的其实也用不了那么多，因此采用CIDR技术，来消除上述不等；举了例子```192.168.1.1/20```表示，前20位是网络号，后面的12位就是主机号。

**子网掩码**：出于CIDR的使用而产生用来区分网络号与主机号，在IPV4中，子网掩码与其长度相同，均为32位。其转换为二进制时，1必须是连续的，有多少个1，就代表IP地址前几位是网络号（即网络地址），后面的则是主机号，可以通过IP地址与子网掩码的与运算确定网络地址。

**WAN**指广域网（互联网），**MAN**指城域网，**SAN**存储区域网络（仅用于存储访问），**CAN**校园网，**LAN**指局域网（家庭、打印店组网），**WLAN**无线局域网（只是不用光缆的局域网），**VLAN**虚拟局域网，**PAN**指个人区域网络（USB、蓝牙等）；以上仅指明范围，与IP无关。

**Socket**：IP地址：端口号=套接字socket，服务端端口通常在1024以下，客户端用1025~1624，相互形成客户/服务器通信；其他策略有远程程序套用（RPC）、管道。

**Mac地址**：物理地址，一张网卡一个，没有重复的，共48位；在OSI模型的数据链路层。

**IPV6**：共128位，前n位是网络地址，后128-n位为主机号；支持內嵌IPV4。

**ARP**：地址解析协议，负责将IP地址转换为MAC地址，用于在物理层面上传输信息；[什么是ARP？它是如何进行地址解析的？ - 华为 (huawei.com)](https://info.support.huawei.com/info-finder/encyclopedia/zh/ARP.html);在同一个网段时，通过查表对应MAC地址，否则进行广播查询（一般来说新设备接网后表上就有记录）。在不同网段时，先发送给网关，由网关再广播查询。

> 表单叫ARP表，包括动态和静态表项。动态表项会随着时间而删除，通常很短，如果有使用就延长；静态ARP表项可以指定通信时固定的MAC与IP的绑定，防止由动态造成的ARP污染

###3 .Cookie

​	首先说明cookie是干什么的：cookie就相当于服务器给你的身份证一样。当你首次登录bilibili的时候，在向网站发送请求时，网站服务器知道有人登陆了，于是就给你的浏览器再额外返回这个Cookie，有了这个Cookie，下次再进入bilibili的时候，就不需要登陆了（也就是b站服务器根据你请求网站时发送过来的Cookie直接确定你的账号，并返回相应内容）;简单来说，cookie就是你的登录信息。

>**客户端发送一个请求到服务器** --> **服务器发送一个HttpResponse响应到客户端，其中包含Set-Cookie的头部** --> **客户端保存cookie，之后向服务器发送请求时，HttpRequest请求中会包含一个Cookie的头部** -->**服务器返回响应数据**

- 接下来是cookie的组成：NAME=value；Expires=date；Path=path；Domain=domain_name；Size；Secure；HttpOnly；

  **1.**NAME就是该cookie的名字；

  **2.**Expires就是该cookie的过期时间（登录好几次之后就又得重新登陆就是因为这个）；**3.**Path在这里的作用并不是路径，而是说再同一网站之中都可以使用这个cookie。举个栗子：根目录为 / ，当你进入b站的任何界面都会发现右上角依然有你的登录信息；

  **4.**Domain决定该cookie在那些域是有效的，下面是关于Domain的不同设置

  > 设为一级域名 `.baidu.com`，则这个域名下的所有二级域名都可以读取该 Cookie；
  >
  > 设为二级域名 `image.baidu.com`，则该 Cookie 只对设置的域名有效

  **5.**Size顾名思义，这个cookie文件多大；

  **6.**Secure就是cookie的安全属性，只有true和false两个值，为true时则浏览器只会在HTTPS和SSL等安全协议中传输cookie，而在其他的诸如HTTP中则不会传递；

  **7.**HttpOnly同上只有true or false两个值当设置为true时，cookie是不允许JS脚本来改变的；

- Session：会话，首先这个东西是存在于服务器的内存中，当用户第一次访问网站时，服务器生成一个session对象，并把该对象的唯一的session_ID作为cookie的一部分发送给客户端；自己设置登出时，就是请求结束对话，会指示服务器把相应的session_ID给删除，本地的cookie并不影响。

### 4. Http/Https

HTTP超文本传输协议，基于TCP/IP协议，默认端口80；HTTPS超文本传输安全协议，用http通信外加SSL/TLS加密数据包，默认端口443。服务端的接收到信息后与CGI交互，解释处理表单内容，产生处理；

+ Http/0.9：请求仅包含一个get方法和URL，响应仅含有HTML文档，如果没找到，则返回有关服务器错误代码。
+ Http/1.0：有了现在的完整请求行和部分请求报头，响应有了状态码的返回，可以支持除HTML文档以外的类型。
+ Http/1.1：完善了Http/1.0，请求报头中增加Host，在传送报文上使用pipe技术，连接可以复用。
+ Http/2：基于SPDY协议，是一种二进制协议而非之前的文本协议，多路复用。
+ Http/3：在传输使用QUIC协议，多路复用协议，延迟更低；在http2中使用单个TCP连接传输，而3中的QUIC使用UDP运行多个流，一旦有错误，仅错误的那条进行重新传输。

1.==无连接==：每次一个请求。2.==媒体独立==：传任何类型数据（content-type规定主体内容格式）。3.==无状态==：对于客户没有记忆能力（搭配cookie使用以保持登陆状态）。

**请求报文**：客户端向服务端首次发送

```
请求方法+空格+请求URL+空+Http版本---------------------------------------请求行
头部字段名：值--------------------------------请求头部/消息报头
空行
（请求正文）
```

| 方法（共8种） | 内容                           |
| ------------- | ------------------------------ |
| get           | 向特定资源发送请求             |
| post          | 请求处理数据，此时含有请求正文 |

| 消息报头        | 解释                                  | 栗子 |
| --------------- | ------------------------------------- | ---- |
| Accept          | 客户端能够接收的文件类型              |      |
| Accept-Charset  | 支持的字符集编码                      |      |
| Accept-Encoding | 浏览器可支持的内容压缩编码类型        |      |
| Accept-Language | 浏览器可接受的语言                    |      |
| Accept-Ranges   | ？？                                  |      |
| Authorization   | Http授权的证书类型                    |      |
| Cache-Control   | 请求响应过程遵循的缓存机制            |      |
| Connection      | 表明是否需要持久连接的                |      |
| Cookie          | 包含在请求URL域名下的所有有关cookie值 |      |
| Content-Length  | 请求的内容长度                        |      |
| Content-Type    | MIME？                                |      |

**响应报文**：

```
http版本+状态码+英文（not found？）-------------------状态行
响应首部------------------------消息报头
空行
主体------------------响应正文
```

**状态码**：xxx+英文字母

| 状态码                      | 栗子                     | 说明                                       |
| --------------------------- | ------------------------ | ------------------------------------------ |
| 1xx(正在处理)               |                          |                                            |
| 2xx(成功)                   | 200(ok)、204(no content) | 请求成功、服务器正常处理，但就是没返回内容 |
| 3xx(重定向，即需要附加操作) | 301、302                 | 请求资源换URL，并返回新家地址、暂时搬走、  |
| 4xx(客户端错误)             | 400、401、403、404       | 请求报文有错误、需要身份验证、拒绝、未找到 |
| 5xx(服务端错误)             | 500、501、503            | 服务器内部错误、不支持请求功能、超载       |

**MIME**：媒体类型，是一种用在响应头中的，表示文件的性质与格式；```type(图片还是文本)/格式(png,html)```,

持久连接+非持久连接：即是否通过相同的TCP连接来通信，同了就是持久连接

<b>Https</b>：在http传输过程的均为明文，https则是对传输内容进行加密；现多采用非对称加密，浏览器拿公钥加密，服务端拿私钥解密。采用SSL进行密钥的协商，由SSL-1.0—2.0—3.0—TLS-1.0—1.1—1.2—1.3；

密钥交换：box中放上需要传输的密钥，A加密box传给B，B收到后用自己的加密回送给A，A解密后再发给B，B解密得到密钥（常用于对称加密）

在这个过程中公钥的传递非常关键，本地得到的公钥需要确定是来自服务端的公钥，因此需要CA进行签名（用自己的私钥对，来自服务端的公钥等信息进行运算），由改签名与服务端等的信息构成的叫做TLS证书；本地拿到证书后，借助该CA的公钥进行对TLS证书上的信息进行运算，如果与签名一致，则表明木有问题，可以相信证书上的服务器公钥；CA灰常！！关键；

TLS=非对称传递对称密钥+对称密钥加密会话：B打招呼并发送第一随机数——C接收，生成第二随机数，返回该数、证书、自己的公钥——B接收后，生成第三随机数（预主密钥），并用公钥加密后返回给C——C接收到后，用私钥解密，得到预主密钥——双方用三个随机数共同加密生成会话密钥——之后进行对称加密进行交流

由于CA的过于重要，于是有了CertificateTransparency（证书透明），CA在颁发证书前，向区块链log，然后返回一个SCT信息，与此一同颁发，客户端验证服务器、CA、区块链日志，都符合后即可。由于区块链的不易更改，有一个更改则后面的都接不上（除非全网50%以上算力），所以可信度提高